\documentclass[../main.tex]{subfiles}

\begin{document}
\chapter{System Design} \label{ch:design}
    The system can be broadly divided into two components: the website and the
        graphics library.
    Both of these components required careful consideration and design to ensure a
        smooth user experience and a robust system.

    \section{The Graphics Library}
        The graphics library is a key component of the system, as it provides the
            functionality for creating images and animations using Haskell.
        The library was not required to produce images itself, as this was handled by
            the browser, but it was responsible for generating the necessary data to render
            the images.
        A graphics library does not need to be overly complex.
        A simple, well-documented API, with selection of graphical primitives and
            transformations, with a few helper modules, is all that is needed to allow
            users of all skill levels to use the library with ease.

        There were several sources of inspiration for the graphics library, including
            CodeWorld and P5.js.
        P5.js is a JavaScript library, and is therefore designed for imperative
            programming, with a large reliance on side effects and global state.
        Despite that, P5.js provides a straightforward API, with a nice selection of
            well-named functions, many of which can be adapted to fit the functional
            programming paradigm.
        CodeWorld, on the other hand, uses Haskell, so it is purely functional, with no
            side effects or global state, relying instead on function composition and
            recursion.
        While CodeWorld's API provides an excellent example of a functional graphics
            library, it is less straightforward than P5.js.
        The aim for our library is to find a balance between the simplicity of P5.js,
            and the functional design of CodeWorld.

        \subsection{The Canvas}
            The first thing needed for a graphics library, is a way to represent the
                two-dimensional space to draw on, i.e. the canvas.
            This can be done with a simple \verb|Canvas| type, with five type parameters:
            \begin{enumerate}
                \item Two \verb|Length|s to represent the width and height of the canvas.
                \item An \verb|Int| to represent the frame rate at which to render the animation.
                \item A \verb|Color| to represent the background colour to apply to each frame.
                      There is an argument for omitting this parameter, requiring users to instead
                          draw a rectangle filling the whole canvas, and applying the background colour
                          there.
                      However, as most animations are likely to use the same background colour for
                          each frame, this provides a more elegant, less repetitive solution.
                \item A \verb|[Shape]| to represent the frames of the animation.
            \end{enumerate}

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:canvas}, caption={The Canvas type definition.
                    We use the field labels for internal use only. These are not exposed to the user, and 
                    are prefixed with \_ to indicate such, as well as to avoid polluting the namespace.}]
data Canvas = Canvas
    { _width :: Length
    , _height :: Length
    , _fps :: Int
    , _backgroundColor :: Color
    , _frames :: [Shape]
    }
                \end{lstlisting}
            \end{minipage}

            Now that we have our \verb|Canvas| type, we need to provide an interface for
                users to interact with it.
            First, we need a function to create a new canvas.
            One option for this function is to take all the canvas parameters as arguments.
            However, this would require the user to write out each parameter in every
                program they write, even if these values are not important to them.
            To provide a more user-friendly interface, the function should provide default
                values for some parameters, requiring the user to only specify the width and
                height.

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:createCanvas}, caption={The createCanvas function.
                Default values are provided for the frame rate, background colour and frames.}]
createCanvas :: Length -> Length -> Canvas
createCanvas width height = Canvas width height 24 Transparent []
                \end{lstlisting}
            \end{minipage}

            To modify the frame rate and background colour, the user can use the \verb|fps|
                and \verb|background| functions, respectively.

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:fps}, caption={The fps function.}]
fps :: Int -> Canvas -> Canvas
fps fps canvas = canvas{_fps = fps}
                \end{lstlisting}
            \end{minipage}

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:background}, caption={The background function.}]
background :: Color -> Canvas -> Canvas
background color canvas = canvas{_backgroundColor = color}
                \end{lstlisting}
            \end{minipage}

            The final interaction the user has with the canvas is to draw shapes on it.
            This is handled by two operators, \verb|(<<<)|, which adds a single
                \verb|Shape|, and \verb|(<<<:)|, which appends a list of \verb|Shape|s.

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:<<<}, caption={The operator to append a single
                    frame to the canvas.}]
(<<<) :: Canvas -> Shape -> Canvas
(<<<) canvas shape = canvas{_frames = _frames canvas ++ [shape]}
                \end{lstlisting}
            \end{minipage}

            \begin{minipage}{\linewidth}
                \begin{lstlisting}[language=Haskell, label={lst:<<<:}, caption={The operator to append an
                    entire list of frames to the canvas.}]
(<<<:) :: Canvas -> [Shape] -> Canvas
(<<<:) canvas shapes = canvas{_frames = _frames canvas ++ shapes}
                \end{lstlisting}
            \end{minipage}

            With these functions, the user can create a canvas, set the frame rate and
                background colour, and draw shapes on it.
            The \verb|(<<<:)| operator was not strictly necessary, as users could instead
                use \verb|foldl (<<<) canvas shapes|, but it provides a more elegant solution.
            Using \verb|foldl| with \verb|(<<<)| would not allow the user to take advantage
                of Haskell's lazy evaluation, as the list of shapes would be fully evaluated
                due to the tail-recursive nature of \verb|foldl|.

        \subsection{Graphical Primitives}
            At the core of the library are the graphical primitives, which are the basic
                building blocks for creating images and animations.
            It made sense to use a similar set of primitives to those found in P5.js, as
                they are simple and easy to use, making them accessible for beginners.
            One option was to ... % TODO: Add more detail here.

            Ultimately, I settled on a \verb|Shape| type, with eight constructors:

            \begin{itemize}
                \item \verb|Empty|, which represents the empty shape, so has no type
                      parameters.
                      Drawing an empty shape has no effect.
                \item \verb|Group|, which represents a group of shapes, so has a single type
                      parameter — a list of shapes.
                \item \verb|Line|, which represents a straight line, so has just one type
                      parameter, of type \verb|Length|, representing the line's length.
                \item \verb|Ellipse|, which represents an ellipse, so has two type parameters,
                      both of type \verb|Length|, representing the ellipse's horizontal and vertical
                      radii.
                \item \verb|Rect|, which represents a rectangle, so has two type parameters, both
                      of type \verb|Length|, representing the rectangle's width and height.
                \item \verb|Polygon|, which represents any polygon, so has one type parameter, of
                      type \verb|[Vector]|, representing the polygon's vertices.
                \item \verb|Curve|, which represents both quadratic and cubic Bézier curves, so has
                      one type parameter, of type \verb|[Vector]|, representing the curve's control
                      points.
                \item \verb|Arc|, which represents an arc, so has five type parameters.
                      Two of type \verb|Length|, representing the horizontal and vertical radii of
                          the arc, two of type \verb|Radians|, representing the start and end angles of
                          the arc, and one of type \verb|Connection|, representing how the arc closes
                          (either \verb|Open|, \verb|Chord| or \verb|Pie|).
            \end{itemize}

            All of these constructors, except for \verb|Empty| and \verb|Group|, take an
                extra type parameter of type \verb|ShapeOptions|.
            This stores the position (\verb|Vector|), angle (\verb|Radians|), fill colour
                (\verb|Color|), stroke colour (\verb|Color|) and stroke weight (\verb|Float|).

            While the \verb|Shape| type is exposed to the user, the constructors are not.
            Instead, the user interacts with the library through a set of functions, such
                as \verb|line|, \verb|ellipse| and \verb|rect|, which construct the shapes for
                the user.
            This allows the user to create shapes with default options, and then modify
                them as needed.

\end{document}
